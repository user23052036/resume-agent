import fetch from "node-fetch";

export interface OpenRouterOptions {
  apiKey?: string;
  apiUrl?: string;
  timeoutMs?: number;
  retries?: number;
  model?: string;
  mockMode?: boolean;
}

export interface ModelResponse {
  response: string;
  responseTime: number;
  model: string;
  success: boolean;
  error?: string;
}

async function sleep(ms: number) {
  return new Promise((res) => setTimeout(res, ms));
}

export async function callOpenRouterLLM(
  input: string,
  instruction: string,
  kind = "resume",
  opts: OpenRouterOptions = {}
): Promise<ModelResponse> {
  const startTime = Date.now();
  const apiKey = opts.apiKey || process.env.OPENROUTER_API_KEY;
  const apiUrl = opts.apiUrl || process.env.OPENROUTER_API_URL || "https://openrouter.ai/api/v1/chat/completions";
  const timeoutMs = opts.timeoutMs ?? 15_000;
  const retries = opts.retries ?? 2;
  const model = opts.model || process.env.OPENROUTER_MODEL || "mistralai/mistral-7b-instruct";

  // Input validation
  if (!input || typeof input !== 'string' || input.trim().length === 0) {
    return {
      response: "",
      responseTime: Date.now() - startTime,
      model,
      success: false,
      error: "Invalid input: text must be a non-empty string"
    };
  }

  // Mock mode for development/testing
  if (opts.mockMode || apiKey === "mock") {
    const mockResponse = `MOCK SUMMARY: ${input.substring(0, 100)}... (generated by ${model} for ${kind})`;
    return {
      response: mockResponse,
      responseTime: Date.now() - startTime,
      model,
      success: true
    };
  }

  if (!apiKey) {
    return {
      response: "",
      responseTime: Date.now() - startTime,
      model,
      success: false,
      error: "OPENROUTER_API_KEY must be set to call OpenRouter LLM"
    };
  }

  const messages = [
    { role: "system", content: instruction },
    { role: "user", content: input },
  ];

  const body = { model, messages, max_tokens: 500 };

  let lastErr: any = null;
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeoutMs);

      const resp = await fetch(apiUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${apiKey}`,
        },
        body: JSON.stringify(body),
        signal: controller.signal as any,
      });
      clearTimeout(id);

      const text = await resp.text();
      const responseTime = Date.now() - startTime;

      if (!resp.ok) {
        // Handle specific error cases
        if (resp.status === 401) {
          return {
            response: "",
            responseTime,
            model,
            success: false,
            error: `OpenRouter API 401: Authentication failed. Please check your API key. Response: ${text}`
          };
        }

        lastErr = new Error(`OpenRouter API ${resp.status}: ${text}`);
        throw lastErr;
      }

      try {
        const json = JSON.parse(text);

        // OpenRouter returns choices[0].message.content
        if (json.choices && json.choices[0] && json.choices[0].message && json.choices[0].message.content) {
          return {
            response: json.choices[0].message.content.toString(),
            responseTime,
            model,
            success: true
          };
        }

        // Fallback for other response formats
        if (json.result) {
          return {
            response: json.result.toString(),
            responseTime,
            model,
            success: true
          };
        }

        if (json.output) {
          return {
            response: json.output.toString(),
            responseTime,
            model,
            success: true
          };
        }

        // If we get here, try to stringify the whole response
        return {
          response: JSON.stringify(json),
          responseTime,
          model,
          success: true
        };
      } catch (parseErr) {
        return {
          response: text,
          responseTime,
          model,
          success: true,
          error: `Response parsing failed, returning raw text: ${parseErr.message}`
        };
      }
    } catch (err) {
      lastErr = err;
      if (attempt < retries) {
        // small exponential backoff
        await sleep(500 * Math.pow(2, attempt));
        continue;
      }
    }
  }

  return {
    response: "",
    responseTime: Date.now() - startTime,
    model,
    success: false,
    error: lastErr ? lastErr.message : "Unknown error calling OpenRouter LLM"
  };
}
